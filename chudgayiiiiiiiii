(* Constants for line following and obstacle avoidance *)
const kp: int = 1
const ki: int = 100
const kd: int = 10000
const s: int = 3800
const ns: int = 300

const rev_speed: int = 110
const fwd_speed: int = 80
const pid_fwd_speed_line: int = 50   (* base speed used in PID/Idle *)
const left_turn_speed: int = 90
const right_turn_speed: int = 90



(* Simple PID controller for line following using five sensors *)
node pid(sen0, sen1, sen2, sen3, sen4: int) returns (v_l, v_r: int)
  var error, i, p, d, temp, out: int;
  let
	error = sen1 - sen3;
	p = error;
	i = 0 -> (pre(i) + error);
	d = error - (0 -> pre(error));
	temp = (p / kp) + (i / ki) + (d / kd);
	out = if (temp < 0) then -10 else 10;
	v_l = if (out = 0) then 75 else (45 - out);
	v_r = if (out = 0) then 75 else (45 + out);
  tel



(* Main node combining line following with obstacle avoidance and line switching *)
node main(sen0, sen1, sen2, sen3, sen4, ir_left, ir_right, top_l, top_r: int; sec: bool) returns (v_l, v_r, dir: int)
  var sen: int^5; last rightEmp:int = 0 ; last leftEmp:int = 0;
  (* var sum: int; *)
  let
	automaton
  	state White
    	do
      	(* Use white-line processing: Think sensor values *)
      	sen = [1023 - sen0, 1023 - sen1, 1023 - sen2, 1023 - sen3, 1023 - sen4];
      	automaton
        	state Idle
          	do
            	dir = 1;  (* Forward *)
            	v_l = 75; v_r = 75;
          	unless (sen[1] < 500 or sen[3] < 500) then Pid
          	| (sen[0] < 500) then Turnleft
          	| (sen[4] < 500) then Turnright
        	state Pid
          	do
            	dir = 2;  (* PID-based correction *)
            	(v_l, v_r) = pid(sen[0], sen[1], sen[2], sen[3], sen[4]);
          	unless (sen[0] < 500) then Turnleft
          	| (sen[4] < 500) then Turnright
        	state Turnleft
          	do
            	dir = 3;  (* Turning left *)
            	v_l = left_turn_speed; v_r = left_turn_speed;
          	unless (sen[1] < 500 or sen[3] < 500) then Pid
          	| sen[4] < 500 then Turnright
        	state Turnright
          	do
            	dir = 4;  (* Turning right *)
            	v_l = right_turn_speed; v_r = right_turn_speed;
          	unless (sen[1] < 500 or sen[3] < 500) then Pid
          	| sen[0] < 500 then Turnleft
        	state Stop
          	do
            	dir = 0;  (* Stop *)
            	v_l = 0; v_r = 0;
          	unless (sen[1] < 500 or sen[3] < 500) then Pid
          	| (sen[0] < 500) then Turnleft
          	| (sen[4] < 500) then Turnright
      	end
    	(* Switch to Black branch when the white sensors indicate the horizontal black line *)
    	unless (sen0 > 600 and sen1 > 600 and sen2 < 600 and sen3 > 600  and sen4 > 600) or (sen0 > 600 and sen1 < 600 and sen2 > 600 and sen3 > 600  and sen4 > 600)
		or (sen0 > 600 and sen1 > 600 and sen2 > 600 and sen3 < 600  and sen4 > 600) then Black
  	state Black
    	
    	do
      	sen = [sen0, sen1, sen2, sen3, sen4];
      	(* sum = sen[0] + sen[1] + sen[2] + sen[3] + sen[4]; *)
      	automaton
        	state Idle
          	do
            	(* In Black branch, check for obstacles first *)
          	 
            	dir = 6;  (* Forward *)
            	v_l = 50; v_r = 50;
          	unless (sen[0] > 850 and sen[1] > 750 and sen[2] > 850 and sen[3] > 750 and sen[4] > 650) then Reverse 
			| (sen[1] < 500 or sen[3] < 500) then Pid
          	| (sen[0] < 500) then Turnleft
          	| (sen[4] < 500) then Turnright
          	| (ir_left = 1 or ir_right = 1) then Obstacle
			| (top_l = 0 or top_r = 0) then ParkingCheck


        	state Pid
          	do
          	 
            	dir = 2;  (* PID-based correction *)
            	(v_l, v_r) = pid(sen[0], sen[1], sen[2], sen[3], sen[4]);
          	unless (sen[0] > 850 and sen[1] > 750 and sen[2] > 850 and sen[3] > 750 and sen[4] > 650) then Reverse 
			| (sen[0] < 500) then Turnleft
          	| (sen[4] < 500) then Turnright
          	| (ir_left = 1 or ir_right = 1) then Obstacle
			| (top_l = 0 or top_r = 0) then ParkingCheck
        	
			state Turnleft
          	do
           	 
            	dir = 3;  (* Turning left *)
            	v_l = left_turn_speed; v_r = left_turn_speed;
          	unless (sen[0] > 850 and sen[1] > 750 and sen[2] > 850 and sen[3] > 750 and sen[4] > 650) then Reverse 
			| (sen[1] < 500 or sen[3] < 500) then Pid
          	| sen[4] < 500 then Turnright
          	| (ir_left = 1 or ir_right = 1) then Obstacle
			| (top_l = 0 or top_r = 0) then ParkingCheck
        	
			
			state Turnright
          	do
           	 
            	dir = 4;  (* Turning right *)
            	v_l = right_turn_speed; v_r = right_turn_speed;
          	unless (sen[0] > 850 and sen[1] > 750 and sen[2] > 850 and sen[3] > 750 and sen[4] > 650) then Reverse
			| (sen[1] < 500 or sen[3] < 600) then Pid
          	| sen[0] < 500 then Turnleft
          	| (ir_left = 1 or ir_right = 1) then Obstacle
			| (top_l = 0 or top_r = 0) then ParkingCheck

			state Reverse
			do
				dir = 4;
				v_l = 50;
				v_r = 50;
			unless ( sen[2] < 600 ) then Idle
			| (top_l = 0 or top_r = 0) then ParkingCheck



        	state Stop
          	var time: int;
          	do
           	 
            	time = 2 -> if(sec) then pre(time) - 1 else pre(time);
            	dir = 0;
            	v_l = 0; v_r = 0;
          	unless (ir_left = 1 or ir_right = 1) then Obstacle 
        	
			state Obstacle
          	do
				v_l = 50;
				v_r = 30;
				dir = 4;
          	unless top_l = 0 then Cross

			state Cross
          	do
				v_l = 40;
				v_r = 40;
				dir = 6;
          	unless top_l = 1 then NewStop


			state NewStop
			do
				v_l = 0;
				v_r = 0;
				dir = 4;
          	unless sen[2]>2000 then Idle
			



			(*-----------Parking-------------*)
			state BlindFor
			var time:int;
			do
				time = 30 -> pre(time) - 1; 
				dir = 2;  (* PID-based correction *)
            	(v_l, v_r) = pid(sen[0], sen[1], sen[2], sen[3], sen[4]);
			until time = 0 then ParkingCheck

			state ParkingCheck
			var time : int;
			do 
				time = 50 -> pre(time) - 1;
				rightEmp = if (top_r = 1 and time = 1) then  last rightEmp + 1 else if (top_r = 0 and time = 1) then 0 else last rightEmp;
				leftEmp = if (top_l = 1 and time = 1) then last leftEmp + 1 else if (top_l = 0 and time = 1) then 0 else  last leftEmp;
				v_l = 0;
				v_r = 0;
				dir = 6;
	
			until (rightEmp = 2) then ParkRight
			|(leftEmp = 2) then ParkLeft
			|(leftEmp < 2 and rightEmp < 2 and time = 0) then BlindFor

			state ParkRight
			var time: int;
			do
				time = 20 -> pre(time) - 1;
				v_l = 40;
				v_r = 40;
				dir = 4;
			until time = 0 then MoveStr

			state ParkLeft
			var time: int;
			do
				time = 20 -> pre(time) - 1;
				v_l = 40;
				v_r = 40;
				dir = 3;
			until time = 0 then MoveStr

			state MoveStr
			var time: int;
			do
				time = 30 -> pre(time) - 1;
				v_l = 60;
				v_r = 60;
				dir = 6;
			until time = 0 then Parked

			state Parked
			do 
				v_l = 0;
				v_r = 0;
				dir = 6;
        	
        end
    end
tel
